#define _CRT_SECURE_NO_WARNINGS
// 입력한 어떤 숫자의 비트(2진수)를 판정하고 싶다.
// 이를 프로그래밍 하시오.
// 힌트 - 쉬프트 연산
#include <stdio.h>

int main()
{
    // 대상을 10으로 잡는다.
    // 00001010 - int만을 대상으로 한다.
    // int는 32비트 데이터 타입
    int num, basis = 8, tmp = 1;

    printf("2진수 변환할 숫자를 적으시오: ");
    scanf("%d", &num);

    // 1 ~ 4   0 ~ 7   8 ~ 15 16 ~ 23 24 ~ 31
    // Intel - 첫번째, 두번째, 세번째, 네번째
    // 정상 - 네번째, 세번째, 두번째, 첫번째
    //        00      00       00     0a
    printf("num = ");

    for (int i = 1; i < 5; i++)
    {
        //           24                       < 32
        //           16                       < 24
        //            8                       < 16
        //            0                       <  8

        // 위의 방식으로 했을때 비트가 거꾸로 출력되는 문제가 있었다.
        // 그러므로 순서를 바꿔줘야 한다.
        //           31 30 29 28 27 26 25      24
        //           23                        16
        //           15                         8
        //            7                         0
        //for (int j = basis * (4 - i); j < basis * (4 - i + 1); j++)
        for (int j = basis * (4 - i + 1) - 1; j >= basis * (4 - i); j--)
        {
            printf("%d", (num >> j) & 0x1);
            if (!(tmp++ % 4))
            {
                printf(" ");
            }
        }
    }

    printf("\n");

    return 0;
}

/* 
16진수

0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f

컴퓨터 아키텍처상 우리가 사용하는 Intel 머신은 Little Endian을 사용한다.
이 경우에 데이터 저장을 크로스 매칭시켜서 저장한다.

0a 00 00 00 - 숫자 10
2c 01 00 00 - 숫자 300

반대로 우리가 사용하는 휴대폰은 ARM 머신을 사용하고 있어
Big Endian을 사용하므로 위와 같은 고려가 필요 없다.
(우리가 일반적으로 생각하는 상식)

00 00 00 0a - 숫자 10
00 00 01 2c - 숫자 300

***** 디버깅

1. 현재 여러분들이 신입이라 가정하고 사수가 어떤 작업을 시켰다.
2. 어떤 기능이 있고 이 기능을 약간 수정해서 보완하는 작업
   - 포인트: 기존의 기능을 파악해야 올바르게 수정을 할 수 있을 것이다.
3. 코드를 분석하다보면 이해가 되지 않는 구간이 존재할 수 있다.
   - 포인트: 그 구간에 커서를 올리고 breakpoint를 잡는다.(F9) - 빨간점
                그리고 F5를 누르면 디버깅이 시작된다.
                디버깅이 시작되면 화살표가 나타난다.
                화살표가 표시하는 구간 전까지 프로그램이 실행됨을 의미함

Shift + F5: 디버깅 강제 종료
F10: 한줄씩 실행하기
F11: 한줄씩 실행하되 함수가 있으면 들어감
*/