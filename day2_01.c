#include <stdio.h>

int main()
{
    char test = 10;
    int num1 = 10, num2 = 5;
    // 10 -> 1010(2)
    //  5 -> 0101(2)

    // <<는 비트를 좌측으로 이동시킨다.
    // 좌측으로 이동시키는데 num2에 있는 값만큼 이동시킨다.
    // num2가 5이므로 5비트를 이동시킨다.

    // 2^8 2^7 2^6 2^5 2^4 2^3 2^2 2^1 2^0
    //                      1   0   1   0    원본(10)
    //                  1   0   1   0   0    1비트 이동(20)
    //              1   0   1   0   0   0    2비트 이동(40)
    //          1   0   1   0   0   0   0    3비트 이동(80)
    //      1   0   1   0   0   0   0   0    4비트 이동(160)
    //  1   0   1   0   0   0   0   0   0    5비트 이동(320)
    // 쉬프트 연산은 기본적으로 비트를 밀고난 다음 0으로 자동채우기를 한다.

    // 10^2 10^1 10^0
    //        1    0
    //   1    0    0
    printf("num1 << num2 = %d\n", num1 << num2);
    printf("num1 << 1 = %d\n", num1 << 1);
    // 우측 쉬프트의 경우에도 좌측 쉬프트와 동일하다.
    // 우측 쉬프트에서 주의할점은 나누기라는 것
    // 그러나 몫만 취하고 소수점 부분의 나머지가 되는 부분을 버림

    // 2^2 2^1 2^0
    //  1   0   1   원본(5)
    //      1   0   1비트 이동(2)
    //          1   2비트 이동(1)
    printf("num2 >> 1 = %d\n", num2 >> 1);
    printf("num2 >> 2 = %d\n", num2 >> 2);

    // 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0 (자리수에 해당하는 인덱스)
    //                                                                                      1  0  1  0
    // 31 ~ 4 까지의 개수를 세어보면 28개가 나온다.
    // 그럼 32비트 이동이므로 4개가 남게 된다.

    // 컴퓨터 구조 - Memory Hierarchy(메모리 계층 구조)
    // 속도 가장 빠른 것 - Register(64비트 - 8, 4, 2, 1바이트 변수들이 만들어질 수 있음)
    // 중간 속도 - Cache(SRAM), DRAM
    // 속도가 가장 느린거 - Disk I/O
    // 레지스터는 속도는 빠르지만 개수가 적음
    // 그래서 어쩔 수 없이 메모리인 DRAM을 사용하게 됨.
    // Overflow가 발생했습니다 ~

    printf("num1 << 32 = %d\n", num1 << 32);

    // 주의 사항: 쉬프트 연산자는 정수형에 한해서 동작시킬 수 있음.
    // float, double에 한해서도 이러한 고속 연산을 수행할 수 있는 방법이 있다.
    // Intel의 SIMD Instruction이라고 하는 것이 있어서 MMX 같은 HW 레지스터를 제어하면
    // float, double에 대해서도 빠른 쉬프트 연산을 적용해줄 수 있음. (보통 게임, 군사용)
    return 0;
}
