// 비트 연산자
// and, or, xor, not, <<, >>
#include <stdio.h>

// 비트란 무엇인가 ?
// 1. 학원 이름
// 2. 정보를 표현할 수 있는 단위 체계(0, 1)

// - 1비트는 정보 2개를 표현할 수 있다.
//   (0, 1)
// - 2비트는 정보 4개를 표현할 수 있다.
//   (00, 01, 10, 11)
// - 3비트는 정보 8개를 표현할 수 있다.
//   (000, 001, 010, 011, 100, 101, 110, 111)
// - 4비트는 정보 16개 ...
// - 5비트는 정보 32개 ...
// - 6비트는 정보 64개 ...
// - n비트는 정보 pow(2, n)개 ...

/* 포인트: 비트가 몇개냐에 따라 표현할 수 있는 숫자가 정해짐 */

// 바이트는 무엇일까 ?
// 1. 단위
// 2. 비트 8개가 모인 단위

// 1바이트(byte) = 8비트
// 2바이트 = 16비트
// 4바이트 = 32비트
// 8바이트 = 64비트

// 데이터 타입과 비트를 연결시켜보자!
// char(문자형) = 1바이트 = 8비트(256개)
// 팁: pow(2, 10) = 1024
// short(정수형) = 2바이트 = 16비트(65536개)
// int(정수형) = 4바이트 = 32비트(42억 9천만 정도)
// float(실수형) = 4바이트 = 32비트(범위는 좀 더 복잡 IEEE표준) - 적당히 높음
// double(실수형) = 8바이트 = 64비트(위와 동일하게 IEEE표준을 따름) - 정밀도 매우 높음
// 쉽게 생각해서 오차가 작다는 것(정밀도 높음)은 0.000000001 을 표현할 수 있냐 없냐로 구분

// 숫자를 비트로 표현해봅시다 ~
// 이것을 할려면 2진수를 알아야 한다.
// ex) 10 진수 12345의 구성을 살펴보자!
//     1 * pow(10, 4) + 2 * pow(10, 3) + 3 * pow(10, 2) + 4 * pow(10, 1) + 5 * pow(10, 0)
//     1 * 10^4 + 2 * 10^3 + 3 * 10^2 + 4 * 10^1 + 5 * 10^0

// ex) 10 진수 10307의 구성을 살펴보자!
//     1 * pow(10, 4) + 0 * pow(10, 3) + 3 * pow(10, 2) + 0 * pow(10, 1) + 7 * pow(10, 0)

// ex) 10 진수 10을 2진수로 표현해보자!
//     주의할 점: 2진수는 표현할 수 있는 숫자가 0과 1 뿐이다.
//     위 두개의 예제를 보면 결론적으로 자리수에 대한 값은 고정이다.
//     그러므로 앞에 x1등등에 오는 값들을 결정만 해주면 된다.
//     그리고 2진수 특성상 0이 올지 1이 올지만 결정하면 된다.

//     10 = 8 + 2
//     x1 * pow(2, 4) + x2 * pow(2, 3) + x3 * pow(2, 2) + x4 * pow(2, 1) + x5 * pow(2, 0)
//     pow(2, 4) = 16으로 10을 표현할 수 없다.
//     그러므로 x1 = 0
//     pow(2, 3) = 8로 10에 포함되므로 x2 = 1
//     현재 8이 설정되었으므로 추가적으로 2가 더 필요하다.
//     pow(2, 2) = 4이므로 2를 초과하기에 x3 = 0
//     pow(2, 1) = 2이므로 남은 값은 0이 되고 x4 = 1
//     pow(2, 0) = 1인데 남은 값이 0이므로 x5 = 0
//     01010 -> 1010(2)

// 연습 문제
// 1. 10진수 73을 10의 자리수 표현 방식으로 표현해보자!
//    7 * 10^1 + 3 * 10^0
//    70 + 3

// 2. 10진수 2773을 10의 자리수 표현 방식으로 표현해보자!
//    2 * 10^3 + 7 * 10^2 + 7 * 10^1 + 3 * 10^0
//    2000 + 700 + 70 + 3

// 3. 10진수 73을 2진수로 변환해보자!
//    73 - 64 = 9
//    9 - 8 = 1
//    1 - 1 = 0
//    2^6 2^5 2^4 2^3 2^2 2^1 2^0
//     1   0   0   1   0   0   1

// x1 * 64 + x2 * 32 + x3 * 16 + x4 * 8 + x5 * 4 + x6 * 2 + x7 * 1
// 73
// if) x1 == 1
// 73 = 64 + y -> y = 9
// 9 = ??? -> x2 = 0, x3 = 0
// if) x4 == 1
// 9 - 8 = 1 -> x5 = 0, x6 = 0
// 1 - 1 -> x7 = 1

// 4. 10진수 2773을 2진수로 변환해보자!
// 2^10 = 1024
// 2^11 = 2048
// 2773 - 2048 = 725
// 725 - 512 = 213
// 213 - 128 = 85
// 85 - 64 = 21
// 21 - 16 = 5
// 5 - 4 = 1
// 1 - 1 = 0
// 2^11 2^10 2^9 2^8 2^7 2^6 2^5 2^4 2^3 2^2 2^1 2^0
//  1    0    1   0   1   1   0   1   0   1   0   1

// 또 다른 방법
// 2773 - 2048 = 725
// 725 - 512 = 213

// * 꼼수 = 255 = 256 - 1
// 256 = 2^8 -> 1 0000 0000
// 256 - 1 = 255 -> 1111 1111
// 1000 - 1 = 999
// 255 - 213 = 42
// 42 = 32 + 8 + 2

// 2048 1024 512 256 128 64  32  16   8   4   2   1
// 2^11 2^10 2^9 2^8 2^7 2^6 2^5 2^4 2^3 2^2 2^1 2^0
//  1    0    1   0   1   1   0   1   0   1   0   1
//                    1   1   1   1   1   1   1   1   ===> 255

// 15를 2 진수로 표현한다.
// 15 - 8 = 7
// 7 - 4 = 3
// 3 - 2 = 1
// 1 - 1 = 1
// 1111(2) = 2^3 + 2^2 + 2^1 + 2^0
// 2^4 - 1 = 16 - 1 = 15
// 10000(2) - 1(2) = 1111(2)

// 30을 2진수로 표현해보자!
// 31 = 32 - 1 = 11111(2)
// 30 = 11110(2)

// 30 = 16 + 8 + 4 + 2
// 2^4 + 2^3 + 2^2 + 2^1
int main(){
    int num1 = 9, num2 = 12;
    int test = 2020;
    // num1 = 10 -> 2진수 변환 => 1010(2) = 8 + 2
    // num2 = 5 -> 2진수 변환 => 101(2) = 4 + 1
    
    // - 컴퓨터에서 참과 거짓 -
    // 0은 거짓, 1은 참
    // and 연산의 특징 -> 참과 참이 만난 경우에만 참이되고 나머지는 모두 거짓
    
    //   num1     1010
    // & num2   & 0101
    // -------  -------
    //            0000
    
    //   num1     1010
    // & num2   & 1101
    // -------  -------
    //            1000
    
    //   num1     1110
    // & num2   & 1101
    // -------  -------
    //            1100
    printf("num1 and num2 = %d\n", num1 & num2);
    
    // or 연산의 특징 -> 참이 하나라도 존재하면 무조건 참
    
    //   num1     1010
    // | num2   | 0101
    // -------  -------
    //            1111
    
    //   num1     1010
    // | num2   | 1001
    // -------  -------
    //            1011
    
    //   num1     1001
    // | num2   | 1100
    // -------  -------
    //            1101
    printf("num1 or num2 = %d\n", num1 | num2); // 원표시를 쉬프트 누르고
    
    // xor 연산의 특징 -> 서로 다른 주장을 하면 무조건 참
    
    //   num1     1010
    // ^ num2   ^ 0101
    // -------  -------
    //            1111
    
    //   num1     1010
    // ^ num2   ^ 1001
    // -------  -------
    //            0011
    
    //   num1     1001
    // ^ num2   ^ 1100
    // -------  -------
    //            0101
    printf("num1 xor num2 = %d\n", num1 ^ num2);
    
    // not의 계산은 대상이 되는 숫자에 +1을 하고 부호를 변경한다.
    // not의 동작은 모든 비트에 대해 부정을 한다.
    // num2   ~ 1100 = 111111...110011
    
    printf("not num2 = %d\n", ~num2);
    
    printf("num << 1 = %d\n", num1 << 1);
    printf("num << num2 = %d\n", num1 << num2);
    
    printf("num >> 1 = %d\n", num1 >> 1);
    printf("num >> 2 = %d\n", num1 >> 2);
    
    // test <- 2020
    // & ~(and not) 동작은 특정한 숫자를 기준으로 정렬을 수행할 수 있다.
    //  2020 -> 2진수
    //  2047 -> 1111 1111 1111
    //  27 = 16 + 8 + 2 + 1
    //  2020 -> 1111 1110 0100
    //  31 ->   0000 0001 1111    (2^n - 1)
    //    ~31 -> 1111 1110 0000
    // & 2020 -> 1111 1110 0100
    // ---------------------------------
    //           xxxx xxx0 0000
    
    //    ~31 -> 1111 1110 0000
    // & 1111 -> 1111 1110 0100
    // ---------------------------------
    //           xxxx xxx0 0000
    //   10 0000 =>  32 = 32 * 1
    //  100 0000 =>  64 = 32 * 2
    // 1000 0000 => 128 = 32 * 4
    // ........  => 256 = 32 * 8
    // ........  => y   = 32 * 2^n
    
    // and의 특성 -> 두 개 모두 참인 경우엔 참이 된다.
    // 하나라도 0이 존재하면 무조건 거짓이다.
    
    //  7777 -> 2진수(1 1110 0110 0001)
    //  1023 -> 1024 - 1 => 100 0000 0000 - 1 = 11 1111 1111
    // ~1023 -> 1111....1100 0000 0000
    //  7777          1 1110 0110 0001
    //---------------------------------
    //   xxxx xxxx xxxx x100 0000 0000
    
    // test로 들어온값을 어떤 상황에도 32의 배수로 정렬한다.
    // & ~(2^n - 1) 자체가 2^n으로 정렬을 하겠다는 의미!
    printf("test를 32개씩 구분하고 싶음 = %d\n", test & ~(31));
    printf("%d\n", 7777 & ~(1023));
    
    return 0;
}


